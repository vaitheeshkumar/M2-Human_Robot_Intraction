#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    IRsensorL,      sensorReflection)
#pragma config(Sensor, in2,    IRsensorR,      sensorReflection)
#pragma config(Sensor, dgtl4,  button1,        sensorTouch)
#pragma config(Sensor, dgtl5,  RF,             sensorSONAR_cm)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           ML,            tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port3,           MR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           GRIP,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/*
ROBOT C code for ONC autonomous underwater robot.
This source code is conveniently divided into four sections.

1 - Global Variables - 	These are all the variables used throughout the source code
												that benefit from being monitored in real time, hence the decision
												to include them as global variables.
2 - Sensor Functions - 	This section contains all the function calls that deal directly
												with sensors values or their manipulation. This includes both infrared
												sensors and the acoustic rangefinder (RF).
3 - Motor Functions - 	These functions all control locomotion or grip manipulation in some fashion.
												They are short functions and are easily identified by their names.
4 - Main Function - 		As suggested in its name, this is the main function which contains the robot's
												decision-making framework via a switch-state with states defined in the enumerated
												"T_State".

The MonitorLightL and MonitorLightR functions are adapted from code given by Dr. Michael McGuire, but
have been heavily modified to operate stereoscopically in order to discern the beacon's location more
easily. They have also been changed from a boolean function to a function pair which, if over a threshhold, returns
an integer value describing the relative intensity of the IR light from a given direction based on a 10Hz beacon.

Please do not to contact any of the group members with questions regarding this code.
-Matthew Fortier, fortier.matt@gmail.com (software developer)

Section B09 Group 048
*/


//******************************* GLOBAL VARIABLES*******************************//


typedef enum {			//These are the various states the robot can
	IDLE_STATE,
	NONE_VISIBLE,
	LEFT_VISIBLE,
	RIGHT_VISIBLE,
	BOTH_VISIBLE,
	WALL_VISIBLE,
	APPROACHING,
	ARRIVED,
	CONNECTED
} T_State;

const int light_threshold = 400; // Adjusts sensitivity of IR detectors.

bool button1_pushed; 	//Flag to store button1 input
int IRLeftValue;			//Flag to store IRLeftValue
int IRRightValue;			//Flag to store IRRightValue
int RFValue;					//Flag to store RangeFinder Value
T_State robot_state;  //Flag to store robot_state


//******************************* SENSOR FUNCTIONS *******************************//


void monitorRF()		//Monitors RangeFinder
{
	RFValue = SensorValue(RF);
}


void monitorInput() // Monitors for button input
{
  if(SensorValue(button1) && !button1_pushed)	{
    button1_pushed = true;
  } else if (SensorValue(button1) && button1_pushed) {
  	button1_pushed = false;
  }

}


void monitorLightL()							// Updates global variable beaconValueL
{
	static int minLevelIRL = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIRL = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIRL = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevelL = SensorValue[IRsensorL];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

	  // 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIRL = maxLevelIRL - minLevelIRL;

		// Reset calculation for next 100 msecs.
		maxLevelIRL = 0;
		minLevelIRL = 4096;
		clearTimer(T1);

	} else {

	  // Check for new minimum/maximum light levels.
	  if ( lightLevelL < minLevelIRL ) {
	  	minLevelIRL = lightLevelL;
	  } else if ( lightLevelL > maxLevelIRL ) {
	    maxLevelIRL = lightLevelL;
	  }
	}

	// Check if light level difference over threshold.
	if ( diffLevelIRL > light_threshold ) {
		IRLeftValue = diffLevelIRL;	//Set difference to global variable
	} else {
	  IRLeftValue = 0;							//Return 0 if under threshold
	}

} //monitorLightL



void monitorLightR()							// Updates global variable beaconValueR
{
	static int minLevelIRR = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIRR = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIRR = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevelR = SensorValue[IRsensorR];

	// Check if 100 msecs have elapsed.
	if ( time1[T2] > 100 )  {

	  // 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIRR = maxLevelIRR - minLevelIRR;

		// Reset calculation for next 100 msecs.
		maxLevelIRR = 0;
		minLevelIRR = 4096;
		clearTimer(T2);

	} else {

	  // Check for new minimum/maximum light levels.
	  if ( lightLevelR < minLevelIRR ) {
	  	minLevelIRR = lightLevelR;
	  } else if ( lightLevelR > maxLevelIRR ) {
	    maxLevelIRR = lightLevelR;
	  }
	}

	// Check if light level difference over threshold.
	if ( diffLevelIRR > light_threshold ) {
		IRRightValue = diffLevelIRR;
	} else {
	  IRRightValue = 0;
	}

} //monitorLightR


bool bothSeen (int sensitivity) {		//This returns true if the difference between the IR Sensors (absolute value) is
																		//within the range of the sensitivity (and the sensors do not both read 0).
	return ((IRRightValue-IRLeftValue < sensitivity) && (IRRightValue-IRLeftValue > (0-sensitivity)) && IRRightValue != 0);
} //bothSeen


//******************************* MOTOR FUNCTIONS *******************************//


void forward() 		//Orders the robot to move forward.
{
	motor[ML] = -60;
	motor[MR] = 60;
} //forward


void stop()				//Orders the robot to stop all locomotion.
{
	motor[ML] = 0;
	motor[MR] = 0;
} //stop


void turn_right()	//Orders the robot to turn right.
{
	motor[ML] = -25;
	motor[MR] = -25;
} //turn_right


void turn_left()	//Orders the robot to turn left.
{
	motor[ML] = 25;
	motor[MR] = 25;
} //turn_left


void reverse()		//Orders the robot to reverse.
{
	motor[ML] = 60;
	motor[MR] = -60;
} //reverse


void open_grip()	//Orders the robot to open the grip (over 750 ms).
{
	motor[GRIP] = -50;
	wait1Msec(750);
	motor[GRIP] = 0;
}

void close_grip()	//Orders the robot to close the grip (over 750 ms).
{
	motor[GRIP] = 50;
	wait1Msec(750);
	motor[GRIP] = 0;
}


//******************************* MAIN FUNCTION *******************************//


task main()
{
	robot_state = IDLE_STATE;	//Begins in the Idle State.

	while( true ) {
		monitorInput();
		monitorLightL();
		monitorLightR();
		monitorRF();


		switch( robot_state ) {

			case IDLE_STATE:										//Idle, waiting to be activated.
				stop();
				if (button1_pushed)														//If button 1 is pushed:
					robot_state = NONE_VISIBLE;									//Switch state to none_visible.
					button1_pushed = false;
				break;	//IDLE STATE

			case NONE_VISIBLE:									//When neither IR detector senses the beacon:
				turn_right();
				if (RFValue < 10 && !bothSeen(500)) { 				//If range finder (RFValue) detects a wall and the beacon is not in front:
					stop();																			//Stop and switch to wall_visible state
					robot_state = WALL_VISIBLE;
				} else if (bothSeen(500)) {										//If both are seen:
					stop();																			//Stop and switch to both_visible state
					robot_state = BOTH_VISIBLE;
				} else if (IRRightValue-IRLeftValue > 500) {	//If right IR Value is much higher:
					stop();																			//Stop and switch to right_visible state
					robot_state = RIGHT_VISIBLE;
				} else if (IRLeftValue-IRRightValue > 500) {	//If left IR Value is much higher:
					stop();																			//Stop and switch to left_visible state.
					robot_state = LEFT_VISIBLE;
				}
				break; //NONE VISIBLE


			case WALL_VISIBLE:									//When a wall is detected in front of the robot:
				if (RFValue <15){									//Reverse only as long as RF reads less than 15 cm.
					reverse();
				} else {
					stop();
					robot_state = NONE_VISIBLE;
				}
				break; //WALL VISIBLE


			case LEFT_VISIBLE:									//When only the left IR detector senses the beacon:
				turn_left();											//Turn left until both are visible or none are visible.
				if (IRLeftValue == 0) {
					robot_state = NONE_VISIBLE;
				} else if (bothSeen(800)) {
					robot_state = BOTH_VISIBLE;
				}
				break; //LEFT VISIBLE


			case RIGHT_VISIBLE:									//When only the right IR detector senses the beacon:
				turn_right();											//Turn right until both are visible or none are visible.
				if (IRRightValue == 0) {
					robot_state = NONE_VISIBLE;
				} else if (bothSeen(800)) {
					robot_state = BOTH_VISIBLE;
				}
				break; //RIGHT VISIBLE


			case BOTH_VISIBLE:									//When both IR detectors sense the beacon in front:
				stop();														//Stop and assess whether the RF reads the beacon as being close enough.
				if (RFValue > 12) {
					robot_state = APPROACHING;									//If no, switch state to approaching.
				} else if (RFValue <= 12) {
					robot_state = ARRIVED;											//If yes, switch state to arrived.
				}
			  break; //BOTH VISIBLE


			case APPROACHING:										//When both beacons are visible but far away:
				forward();												//Move forward.
				if (!bothSeen(800)) {												//If both no longer seen:
					stop();																			//Switch back to right_visible state.
					robot_state = NONE_VISIBLE;
				} else if (bothSeen(800) && RFValue <= 12) {	//If both are still visible and the Rangefinder reads close:
					stop();																			//Stop and switch state to arrived.
					robot_state = ARRIVED;
				}
				break; //APPROACHING


			case ARRIVED:												//When arrived at the beacon:
				stop();
				open_grip();																//Issue a series of commands to open the grip and back away,
				wait1Msec(500);															//Then switch state to connected.
				reverse();
				wait1Msec(3000);
				stop();
				turn_left();
				wait1Msec(3000);
				stop();
				robot_state = CONNECTED;
				break;	//ARRIVED


				case CONNECTED:								//Triggered after connecting object to beacon and backing away.

					forward();
					if (RFValue <= 15) {				//Moves forward to the edge of the arena, closes grip.
						stop();
						close_grip();
						open_grip();
						button1_pushed = false;
						robot_state = IDLE_STATE;	//Switches state back to idle_state.
					}
					break;	//CONNECTED


			default:
				// This should never happen.
			  robot_state = IDLE_STATE;
		} // switch
	}  // while
} // main
